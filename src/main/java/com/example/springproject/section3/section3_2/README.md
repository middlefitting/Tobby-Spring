# 변하는 것과 변하지 않는 것

### 문제점
- close 실수하면 발견하기 어려운 버그가 된다.

### 분리와 재사용을 위한 디자인 패턴 적용
- 템플릿 메소드 패턴을 적용해서 바뀌지 않는 부분을 고정시키면 중복을 줄일 수 있다.
    - 변하지 않는 부분은 슈퍼클래스에, 변하는 부분은 추상 메소드로 정의해둬서 오버라이드해서 사용

### 템플릿 메서드 패턴의 한계
- DAO 로직마다 상속을 통해 새로운 클래스를 만들어야 한다.
- 확장구조가 클래스를 설계하는 시점에서 고정되어 버린다.
  - 상속 시점에 관계가 결정되어 있다는 것 == 강하게 결합된다. == 유연성이 떨어진다.

### 전략 패턴의 적용
- 오브젝트를 둘로 분리하고 클래스 레벨에서는 인터페이스를 통해서만 의존
- 확장에 해당하는 변하는 부분을 별도의 클래스로 만들어서 위임
- 구성
  - context: 일정한 구조를 가지고 동작
  - strategy: 확장 기능을 인터페이스를 통해 외부의 독립된 전략 클래스에 위임

### 변하지 않는 맥락
- JDBC를 이용해 DB를 업데이트
  - DB 커넥션 가져오기
  - PreparedStatement 를 만들어줄 외부 기능 호출
  - 전달받은 PreparedStatement 실행
  - 예외가 발생하면 던지기
  - 모든 PreparedStatement, Connection 닫아주기

### 전략
- PreparedStatement 를 만들어주는 외부기능

### DI 적용을 위한 클라이언트/컨텍스트 분리
- Context 가 어떤 전략을 사용하게 할 것인가는 앞단에 Client 가 결정하는 것이 일반적
- DI 의존관계 주입과 같은 메커니즘이다.
  - DI는 전략 패턴의 장점을 일반적으로 활용할 수 있도록 만든 구조
  - 전략 오브젝트 생성과 컨텍스트 전달을 담당하는 책임을 분리 시킨 것이 ObjectFactory

### 컨텍스트 메소드 분리
- 컨텍스트를 메소드로 분리해서 재사용하고, 전략을 전달하는 클라이언트 코드를 작성한다. 메소드에 전략을 전달
- 클라이언트가 컨텍스트가 사용할 전략을 정해서 전달하는다는 면에서 DI 구조라고 할 수도 있다.

### 마이크로 DI
- DI의 중요한 점은 제 3자의 도움을 통해 관계를 유연하게 만든다는 것
- DI 구성 요소
  - 의존관계인 두 오브젝트
  - 다이내믹 오브젝트 팩토리
  - 클라이언트
- 마이크로 DI는 매우 작은 코드와 메소드 사이에서 일어난다.










